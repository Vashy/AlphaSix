\section{Processi primari}\label{ProcessiPrimari}

    \subsection{Processo di fornitura}\label{PP:Fornitura}	%istanziare Management Process, Infrastructure Process e Improvement Process

        \subsubsection{Scopo}\label{PP:Fornitura:Scopo}
		La sezione corrente ha lo scopo di riportare le attività principali che ci impegniamo ad attuare come \gloss{fornitori} per la proponente \II. \par
        Il processo si fornitura ha lo scopo di curare e mantenere i rapporti con le figure esterne al gruppo \gruppo. Questi perciò devono essere costanti, sensati e che sappiano dare un valore aggiunto al progetto.

		\subsubsection{Ricerca delle tecnologie}
		Ognuno di noi deve approfondire la propria conoscenza su tecnologie e \gloss{framework} vari, in modo da discutere insieme quali sono quelli di interesse comune e di utilità per il progetto. Questo prevede in seguito l'auto-formazione di quelle scelte in comune accordo per acquisirne una buona padronanza.

		\subsubsection{Normazione}\label{Normazione}
		L'attività di normazione prevede l'incremento del documento corrente ogni qual volta lo si ritiene necessario.
		Essendo infatti un documento incrementale, è possibile che vengano aggiunte delle nuove regole o aggiornate quelle già presenti.
		Facendo un esempio: arrivati al momento di riscrittura dei casi d'uso, dopo la prima revisione, abbiamo dovuto suddividere i casi in categorie ben distinte, in modo che fosse evidente il sottosistema di riferimento di \progetto.
		Di conseguenza è necessario cambiare il codice identificativo dei casi d'uso e la relativa norma nel paragrafo \S\ref{PP:Sviluppo:AdR:CasiUso}.
        
        \subsubsection{Strumenti forniti}
        Il proponente e il \TV~ ci hanno messo a disposizione diversi strumenti per la realizzazione del progetto e come raggiungere una buona qualità nei prodotti. \par
        Il \TV~ è a disposizione per:
        \begin{itemize}
            \item Chiarire eventuali dubbi relativi alla realizzazione del progetto in termini di buone pratiche e regole per la sua realizzazione
            \item Mettere a disposizione materiale didattico per il corretto sviluppo delle varie fasi del progetto, e la stesura della documentazione
        \end{itemize}
        Il proponente \DZ~ di \II\ ci mette a disposizione:
        \begin{itemize}
            \item Un \gloss{cluster} dell'azienda su cui è installato \gloss{Rancher} per installare in remoto i \gloss{container} necessari a \progetto
            \item Un indirizzo Email col dominio di \II~per inviare i messaggi da \progetto
        \end{itemize}
        Anche \DZ~ è disponibile a degli incontri via \gloss{Hangounts} per eventuali chiarimenti tecnici sullo sviluppo del progetto.

        \subsubsection{Studio di fattibilità}\label{PP:Fornitura:SdF}
        In quest'attività viene prodotto il documento \Doc{\SdFv} al fine di analizzare ogni \gloss{capitolato} e scegliere quale contratto accettare.
        Nello specifico, il documento in ogni sezione contiene:
        	\begin{itemize}
        		\item \textbf{Descrizione generale}: breve descrizione del capitolato.
        		\item \textbf{Obiettivo finale}: obiettivo da raggiungere.
        		\item \textbf{Tecnologie coinvolte}: elenco delle tecnologie direttamente coinvolte esplicitate nel capitolato.
        		\item \textbf{Valutazione conclusiva}: giudizio finale del team di sviluppo.
        	\end{itemize}
        Tale documento è fondamentale per chiarire ai vari proponenti la scelta di un capitolato, chiarendone i punti di forza e quelli deboli secondo il nostro punto di vista. In questo modo il cliente può già osservare quali possono essere le nostre competenze e abilità.
        
        
        % DA ISO12207
        % 5.2.6.1 The suppli er should coordina te contract review activities, interfaces, and communi cation with the acqui rer’s organi zation.
        \subsubsection{Coinvolgimento dell'acquirente} \label{ConivolgimentoAcquirente}
        Data la natura del progetto, riteniamo essenziale la comunicazione con il cliente per qualunque tipo di aggiornamento rilevante, come ad esempio una \gloss{baseline}.
        In particolare, avere un \gloss{feedback} da parte del cliente ci è molto utile ai fini del proseguimento del progetto.
        Per esempio, un feedback del nostro \gloss{Proof of Concept} ci aiuta a capire se stiamo realizzando il prodotto come \II\ lo aveva ideato.
        Per ricevere questo feedback e procedere ad uno scambio di idee e opinioni, preferiamo staibilire un colloquio.
        Questo colloquio può avvenire tramite:
        \begin{itemize}
            \item Un incontro di persona in un luogo fissato insieme (e.g. aula universitaria, bar, ecc.)
            \item Una videochiamata con una tecnologia scelta (e.g. \gloss{Hangouts})
        \end{itemize}
        In alternativa al colloquio, nel caso di brevi domande volte al chiarimento di piccoli dubbi, è possibile combinare una serie di Email o messaggi Telegram.
        
        % 5.2.3
        % Contract. This activity consists of the foll owing tasks:
        % 5.2.3.1 The supplier shall negotiate and enter into a contract with the acquirer organ ization to provide
        % the software product or service.
        % 5.2.3.2 The supplier may request modification to the contract as part of the chang e control
        % mechanism.
        \paragraph{Negoziazione} \label{Negoziazione}
        Talvolta, in corso d'opera, è necessario negoziare gli accordi da contratto precedentemente presi con il cliente.
        Questo può accadere per più motivi, principalmente in momenti in cui noi fornitori realizziamo di non poter soddisfare qualche requisito nel modo in cui lo vorrebbe il nostro cliente.
        In seguito ad un inconveniente come questo, riteniamo necessario richiedere un colloquio con il cliente per poter esporre la nostra proposta alternativa e definire dei cambiamenti tali da assecondare i bisogni di entrambe le parti. \par
        A seguito di un cambiamento in accordo col committente è d'obbligo riportare i cambiamenti all'interno dell'\AdRd~ che risulta essere il contratto che tutela il fornitore e il committente per quanto riguarda i requisiti che il prodotto finale deve soddisfare.
        
        % 5.2.6.4 The supplier shall make available to the acquirer the reports of evaluation, reviews, audits,testing, and problem resolutions as specified in the contract.
        \paragraph{Accessibilità del materiale necessario da contratto} \label{AccessibilitaMateriale}
        Tutta la documentazione richiesta dall'acquirente come resoconti dei problemi riscontrati, \gloss{bug} reporting, istruzioni per l'avvio del prodotto, ecc\dots\ devono essere resi accessibili al cliente. \par
        Questo può avvenire attraverso email, Drive \footnote{Riferirsi alla voce 13 in \S\ref{rifinfo} per ulteriori informazioni su Drive} o repository pubblica su GitHub.
        % 5.2.7.1 The supp lier shall deliver the software product or service as specified in the contract.
        Oltre alla documentazione, anche il prodotto software deve essere rilasciato come specificato nel contratto.
        
        % User involvement; by such means demonstrations and evaluations;
        \subsubsection{Coinvolgimento del committente} \label{CoinvolgimentoCommittente}
        % Nel corso del progetto abbiamo posto delle milestone al fine di
        Durante alcune baseline, ad esempio le revisioni,
        illustriamo al committente delle dimostrazioni del nostro prodotto in modo da ottenere anche da esso una valutazione utile per noi all'avanzamento del progetto.
        
        \paragraph{Accessibilità del materiale relativo alle revisioni} \label{AccessibilitaMaterialeRevisioni}
        Per ogni revisione di avanzamento e accettazione rendiamo disponibile il materiale richiesto dal committente tramite:
        \begin{itemize}
            \item \textbf{Drive}: per ogni revisione rendiamo disponibile su \gloss{Google Drive} l'ultima versione dei documenti relativi a \progetto
            \item \textbf{GitHub}: il codice del prodotto è disponibile in una \gloss{repository} pubblica. Tale repository non risulta essere il luogo dove il software viene sviluppato, ma solo il codice prodotto dopo una data revisione
            \item \textbf{CD-ROM}: il prodotto finale e  installabile viene consegnato al committente all'interno di un CD-ROM per motivi di sicurezza
        \end{itemize}

        \subsubsection{Preparazione in vista della revisione}
		In questa attività prepariamo tutto il materiale necessario per il buon superamento della revisione:
		\begin{itemize}
			\item I vari documenti, i verbali e la lettera di presentazione per quanto riguarda la documentazione in ingresso
			\item I diagrammi \gloss{UML} e il codice necessario per il superamento delle varie revisioni del progetto
			\item Le diapositive per l'esposizione
            \item Demo di dimostrazione del prodotto
		\end{itemize}
    
        \paragraph{Collaudo finale}
        In vista del collaudo finale, grazie ai vari confronti con il \TV~ e \DZ, tutti i documenti dovranno essere corretti nella forma e nei contenuti, almeno per quanto riguardano le correzioni fatte in sede di revisione. I requisiti richiesti dal capitolato ed inseriti in \AdRd dovranno essere totalmente soddisfatti, insieme anche ad eventuali richieste marginali di \DZ. \par
        La presentazione di \progetto\ attraverso una demo deve poter essere efficace mostrando la maggior parte delle funzionalità del progetto in modo chiaro e veloce, e poter far fronte ad eventuali richieste del committente. \par
        In sede di collaudo dobbiamo mostrare i possibili upgrade e miglioramenti di \progetto, in modo da trasmettere il potenziale dell'applicazione.



		\subsubsection{Verifica post revisione} \label{verificapostrevisione}
        In seguito alla valutazione di ogni revisione riteniamo necessario conoscere i motivi negativi, ma anche positivi, di tale giudizio. In tal modo possiamo correggere meglio i difetti dei nostri prodotti e migliorarne i punti di forza. \par
        Se sono presenti molteplici dubbi in rapporto alle correzioni riportate o ci sembra utile un confronto, entro la settimana successiva alla pubblicazione del giudizio della revisione, cerchiamo di fissare, se possibile, un colloquio con:
        \begin{itemize}
            \item \textbf{Proponente}: \DZ\ di \II.
            \item \textbf{Committente}: \TV\ e \RC.
		\end{itemize}
    
        \subsubsection{Circoscrizione dei rischi}
        Nell'eventualità che si possa presentare un problema all'interno del gruppo o con i prodotti di \progetto, può essere necessario comunicarlo a \DZ~ o a il \TV~. Tale comunicazione deve presentare in modo chiaro il problema e, se possibile, allegare un'eventuale soluzione. \par
        Ad esempio: durante il periodo di progettazione ci siamo accorti che la metodologia di inoltro dei messaggi risultava incoerente in alcuni aspetti, questo ci ha portato a pensare ad una diversa gestione delle priorità dei progetti. Subito dopo abbiamo contattato \DZ~ per mostrare il problema e la possibile soluzione che l'ha approvata con qualche modifica.


    \subsection{Processo di sviluppo}\label{PP:Sviluppo}

		\subsubsection{Scopo}\label{PP:Sviluppo:Scopo}
		Lo sviluppo consiste nell'affrontare le attività volte a produrre il software richiesto dal proponente.
		Per una corretta implementazione di questo \gloss{processo}, è necessario:
		\begin{itemize}
			\item Fissare degli obiettivi di sviluppo
			\item Realizzare un prodotto che sia conforme a:
			\begin{itemize}
				\item \gloss{Requisiti} definiti dal proponente
				\item Test definiti dalle norme di \gloss{qualità}
			\end{itemize}
		\end{itemize}
		Lo standard ISO/IEC 12207:1995\footnote{Riferirsi alla voce
		%``ISO/IEC 12207''
		2
		 in \S\ref{rifinfo}} definisce il processo di
		sviluppo quel processo contenente tutte le attività relative al prodotto finale, quali:
		\begin{itemize} % [noitemsep]
			\item Analisi dei requisiti
			\item Progettazione
			\item Codifica
			\item Integrazione ed installazione
		\end{itemize}


        \subsubsection{Analisi dei requisiti}\label{PP:Sviluppo:AdR}
		Gli Analisti si occupano di redigere l'\Doc{\AdRv}, composta come segue:
		\begin{itemize}
			\item Descrizione generale del prodotto
			\item Modellazione concettuale del \gloss{sistema} tramite la definizione dei vari \gloss{casi d'uso}
			\item Classificazione e tracciamento dei requisiti
		\end{itemize}

		\paragraph{Denominazione dei requisiti}\label{PP:Sviluppo:AdR:DenominazioneRequisiti}
		Ogni requisito che è stato individuato durante l'analisi presenta il seguente identificativo univoco:
		\begin{center}
			\texttt{R[Numero][Tipo][Priorità]}
		\end{center}

		\begin{itemize}
			\item \textbf{R}: si riferisce a requisito.
		 	\item \textbf{Numero}: corrisponde ad un numero che cerca di seguire la struttura del documento ed è progressivo. Inizia da 1.
		 	\item \textbf{Tipo}: segnala la tipologia di requisito che può essere di:
		 	\begin{itemize}
		 		\item \textbf{F}: funzionalità, che ha a che vedere con le funzionalità del sistema software.
		 		\item \textbf{Q}: qualità, che riguarda tecniche ad hoc.
		 		\item \textbf{V}: vincolo, proposto da \II.
		 	\end{itemize}
	 		\item \textbf{Priorità}: indica il grado di urgenza per il soddisfacimento di un requisito, come:
	 		\begin{itemize}
	 			\item \textbf{0}: opzionale, di grado basso e solo marginalmente utile.
	 			\item \textbf{1}: desiderabile, di medio livello quindi non strettamente necessario ma che dà valore aggiunto.
	 			\item \textbf{2}: obbligatorio, di grado alto quindi irrinunciabile per il \gloss{committente} e impossibile da tralasciare.
	 		\end{itemize}
		\end{itemize}

		Esempio: \texttt{R2Q1} indica il secondo requisito di qualità ed è desiderabile.


		\paragraph{Metriche sui requisiti}\label{MetricheAdR}
		Dato che non è fisso il numero dei requisiti di un progetto, abbiamo scelto una serie di metriche dove il valore ottimale da raggiungere è sempre uguale, lo zero. Abbiamo anche scelto di contare il numero di requisiti non soddisfatti invece che il contrario. Lo stesso ragionamento è valido per quanto	riguarda i rischi che possono verificarsi nel corso del progetto.
		Gli obiettivi che si vogliono raggiungere attraverso tali metriche possono essere stabiliti solo a progetto concluso.

		La denominazione delle metriche è descritta in \S\ref{Classificazione metriche}.

		\subparagraph{MPR005 Requisiti obbligatori non soddisfatti}
		Per adempiere completamente alla richiesta del cliente, ci serve individuare tutti i requisiti presenti nella sua richiesta, impliciti, espliciti, diretti e derivati. Alcuni sono imprescindibili, detti obbligatori, e il loro soddisfacimento determina la buona riuscita del progetto.

		\textbf{Metrica}: numero dei requisiti obbligatori non soddisfatti.

		\subparagraph{MPR006 Requisiti desiderabili non soddisfatti}
		I requisiti desiderabili non sono necessari, ma offrono un valore aggiunto al progetto.

		\textbf{Metrica}: numero dei requisiti desiderabili non soddisfatti.

		\subparagraph{MPR007 Requisiti opzionali non soddisfatti}
		Tali requisiti dovranno essere adempiuti solo nel momento in cui tutti i requisiti obbligatori saranno soddisfatti.
		Possono essere concordati col cliente in corso d'opera.

		\textbf{Metrica}: numero dei requisiti opzionali non soddisfatti.


		\paragraph{Casi d'uso}\label{PP:Sviluppo:AdR:CasiUso}
		Un caso d'uso è una tecnica che identifica i requisiti funzionali descrivendo le interazioni tra il sistema di riferimento e un utente ad esso esterno.\par
		Ogni caso d'uso che si vuol descrivere presenta:
		\begin{itemize}
		 	\item \textbf{Codice}: per l'identificazione.
		 	\item \textbf{Titolo}: denominazione del caso d'uso, possibilmente breve.
		 	\item \textbf{Attori primari}: tutti gli \gloss{attori} primari coinvolti.
		 	\item \textbf{Attori secondari}: opzionale, tutti gli attori secondari coinvolti.
		 	\item \textbf{Descrizione}: per spiegare più nel dettaglio le azioni che vengono compiute.
		 	\item \textbf{Precondizione}: per rappresentare lo stato del sistema nell'istante precedente.
		 	\item \textbf{Postcondizione}: per rappresentare lo stato del sistema l'istante successivo.
		 	\item \textbf{Scenario principale}: contenente la serie di azioni da compiere numerate nell'ordine in cui vengono compiute.
		 	\item \textbf{Estensioni}: opzionale, per azioni inerenti a scenari alternativi come d'eccezione o errore.
		\end{itemize}

		\subparagraph{Denominazione del codice identificativo}
		Ogni codice presenta una forma del tipo:
		\begin{center}
			\texttt{UC[Numero]-[Sottosistema]}
		\end{center}

		\begin{itemize}
			\item \textbf{UC}: sta per ``User Case'', l'equivalente inglese di ``caso d'uso''.
			\item \textbf{Numero}: numero progressivo che si riferisce al caso. Se il caso d'uso è principale, è un semplice intero (e.g. 1 per il primo caso d'uso). Mentre se è un sotto caso, presenta due interi separati da un punto (e.g 1.1 per per il primo figlio del primo caso d'uso).
			\item \textbf{Sistema}: indica il sistema preso come riferimento per il caso d'uso, che può essere Butterfly o un suo sottosistema:
			\begin{itemize}
				\item \textbf{PR}: Producer Redmine.
				\item \textbf{PG}: Producer Gitlab.
				\item \textbf{GP}: Gestore Personale.
				\item \textbf{CT}: Consumer Telegram.
				\item \textbf{CE}: Consumer Email.
				\item \textbf{BT}: bot Telegram.
				\item \textbf{SE}: server Email.
			\end{itemize}
		\end{itemize}

		Vi possono essere al massimo tre livelli di annidamento, come nel seguente esempio:
		\begin{itemize}
			\item \texttt{UC1} identifica il caso d'uso con il numero 1
			\item \texttt{UC1.1} identifica il sottocaso 1 del caso d'uso 1
			\item \texttt{UC1.1.1} identifica il sottocaso 1 del caso d'uso 1.1
		\end{itemize}
		Per ogni livello i numeri partono da 1.

		\subparagraph{Diagrammi dei casi d'uso}\label{PP:Sviluppo:DiagrammiCasiUso}
		Per i diagrammi dei casi d'uso utilizziamo lo strumento \gloss{Draw.io} e il linguaggio \gloss{UML} 2.0.\par
		Essi descrivono la visione di un utente
		esterno al sistema e non danno nessun dettaglio implementativo. I \gloss{componenti} contenuti in questo tipo di diagrammi sono:
		\begin{itemize}
			\item \gloss{Attore}
			\item Casi d'uso
			\item Relazioni, che possono essere di:
			\begin{itemize}
				\item \textbf{Associazione}: è sempre presente e rappresenta una comunicazione diretta dell'attore con il caso d'uso.
				\item \textbf{Inclusione}: è una funzionalità comune che coinvolge più casi d'uso, in cui ogni istanza del primo esegue
					necessariamente il secondo. Tutte le inclusioni vengono sempre eseguite dall'utente.
				\item \textbf{Estensione}: aumenta le funzionalità di un caso d'uso coinvolgendone un altro. L'esecuzione di quest'ultimo interrompe il precedente, ma non è necessariamente detto che tutte le estensioni vengano eseguite.
				\item \textbf{Generalizzazione}: avviene tra casi d'uso o tra attori e rappresenta delle modifiche alle caratteristiche di base.
			\end{itemize}
		\end{itemize}
		Per la specifica di un caso d'uso si fa riferimento al paragrafo \S\ref{PP:Sviluppo:AdR:CasiUso}.

        \subsubsection{Progettazione}\label{PP:Sviluppo:Progettazione}
        La progettazione è l'attività svolta dai progettisti con il fine di dare una soluzione soddisfacente per tutti gli stakeholder coinvolti nel rispetto delle \gloss{best practice} e dei design pattern scelti, attraverso la descrizione dell'architettura del software.

		\paragraph{Obiettivi}\label{PP:Sviluppo:Progettazione:Obiettivi}
        Gli obiettivi dell'attività di progettazione sono:
        \begin{itemize}
			\item Definire l'architettura logica del prodotto.
			\item Organizzare le responsabilità di realizzazione.
			\item Garantire la qualità del prodotto finale.
		\end{itemize}

        \paragraph{Strumenti}

		\subparagraph{Diagrammi dei package}\label{PP:Sviluppo:DiagrammiPackage}
        Per i diagrammi dei package utilizziamo lo strumento \gloss{Draw.io} e il linguaggio UML 2.0.\par
        Vengono usati insieme ai diagrammi delle classi per raggrupparne gli elementi in un elemento di livello più alto.
        Rappresentiamo i package con un rettangolo che contiene altri package o classi, e un'etichetta con il nome del package.
        Ogni package identifica uno spazio dei nomi, che serve per dare un nome qualificato alle classi.
        Gli elementi di un package possono avere visibilità pubblica (+) o privata (-) verso l'esterno.
		Nella progettazione adottiamo il principio del common closure principle, secondo il quale elementi dello stesso
		package condividono la stessa causa di cambiamento.
        Indichiamo le dipendenze tra package con frecce tratteggiate.
        Rappresentiamo le dipendenze perché:
        \begin{itemize}
            \item Individuiamo subito le dipendenze circolari, evitandole
            \item Vediamo quali elementi dovrebbero essere più stabili (avendo più dipendenze entranti)
        \end{itemize}

		\subparagraph{Diagrammi delle classi}\label{PP:Sviluppo:DiagrammiClassi}
		Per i diagrammi delle classi utilizziamo lo strumento \gloss{Draw.io} e il linguaggio UML 2.0.\par
        Questi diagrammi strutturali descrivono ad alto livello i tipi di oggetto presenti nel sistema e le relazioni che intercorrono tra essi.
		I diagrammi delle classi sono composti dalle seguenti proprietà:
		\begin{itemize}
			\item \textbf{Attributi}: rappresentano lo stato dell'oggetto. Presentano le caratteristiche:
			    \begin{itemize}
			        \item \textbf{Visibilità}: pubblica (+), privata (-) o protetta (\#) rispetto alle altre classi.
			        \item \textbf{Nome}: nome dell'attributo.
			        \item \textbf{Tipo}: tipo dell'attributo (intero, stringa\dots).
			        \item \textbf{Molteplicità}: numero di occorrenze dell'attributo (opzionale).
			        \item \textbf{Default}: valore di default dell'attributo (opzionale).
                    \item \textbf{Altro}: \dots~(opzionali)
			    \end{itemize}
			\item \textbf{Associazioni}: rappresentano legami tra classi ed hanno un nome.\par
                        Le rappresentiamo con linee continue orientate tra due classi.
		\end{itemize}
        Nella parte bassa del rettangolo delle classi rappresentiamo le operazioni fornite dalla classe, composte da:
        \begin{itemize}
            \item \textbf{Visibilità}: come per gli attributi.
            \item \textbf{Nome}: nome dell'operazione.
            \item \textbf{Lista dei parametri}: parametri necessari all'operazione. Sono formati da:
            \begin{itemize}
                \item \textbf{Direzione}: indica se il parametro è in lettura (in), scrittura (out) o entrambi (inout). Opzionale, di default è in lettura.
                \item \textbf{Nome}: nome del parametro.
                \item \textbf{Tipo}: tipo del parametro.
                \item \textbf{Default}: valore di default del parametro (opzionale).
            \end{itemize}
            \item \textbf{Tipo di ritorno}: tipo ritornato dall'operazione.
        \end{itemize}
        Tra le classi rappresentiamo le seguenti relazioni di dipendenza:
        \begin{itemize}
            \item \textbf{Dipendenza}: rappresentata da una linea orientata tratteggiata, indica che una classe usa un'operazione fornita dalla classe puntata.
            \item \textbf{Associazione}: rappresentata da una linea continua semplice, indica che una classe possiede uno o più attributi (a seconda delle molteplicità indicate sulla linea) dell'altra, o viceversa.
            \item \textbf{Aggregazione}: rappresentata da un diamante vuoto seguito da una linea continua, indica che una classe (puntata dal diamante) possiede un'istanza di un'altra classe tra gli attributi. Tale istanza può essere condivisa.
            \item \textbf{Composizione}: rappresentata da un diamante pieno seguito da una linea continua, è come l'aggregazione ma in tal caso l'aggregato non è condiviso tra più istanze.
            \item \textbf{Generalizzazione}: rappresentata da una freccia vuota, indica che ogni classe che punta verso un'altra è anche un'istanza di essa (eredita metodi e attributi).
        \end{itemize}
        Usiamo inoltre i seguenti costrutti:
            \begin{itemize}
                \item \textbf{Classi astratte}: il nome è indicato in corsivo, non possono essere istanziate. Presentano almeno un'operazione astratta (con il nome in corsivo) e possono avere attributi.\par
                Tali classi generalizzano altre classi che devono implementare le operazioni astratte per essere istanziate, altrimenti sono anch'esse astratte e generalizzano altre classi.
                \item \textbf{Interfacce}: indicate da un pallino vuoto e una linea continua verso classi, presentano solamente le operazioni che vengono implementate dalle classi collegate con la linea.\par
                Possono essere indicate con un pallino vuoto e un semicerchio a destra per indicare che l'interfaccia viene usata da un componente in un punto qualsiasi (ritorno di un'operazione, attributo\dots).
            \end{itemize}

		%\subparagraph{Semantica}
		%Dipendenza generica, Associazione, Aggregazione..
        %Meglio qui o lasciamo sopra?


%		\paragraph{Diagrammi di attività}\label{PP:Sviluppo:DiagrammiAttività}
%        Per i diagrammi di attività utilizziamo lo strumento \gloss{Draw.io} e il linguaggio \gloss{UML} 2.0.\par
%		Li usiamo per descrivere la logica dell'applicazione, ovvero quali attività si possono presentare e in quali sequenze vengono svolte. Rappresentano quindi la parte dinamica dei casi d'uso.\par
%        Le attività sono insiemi di azioni ordinate dei tipi:
%        \begin{itemize}
%            \item \textbf{Nodo iniziale}: rappresentato da un pallino pieno, è l'inizio dell'attività.
%            \item \textbf{Fork}: rappresentato da un tratto marcato, indica l'inizio di elaborazioni parallele.
%            \item \textbf{Join}: rappresentato da un tratto marcato, indica un punto di sincronizzazione tra elaborazioni parallele.\par
%                Vengono indicate specifiche di join tra parentesi quadre (espressioni booleane).
%            \item \textbf{Branch}: rappresentato da un rombo vuoto, indica che si può intraprendere solo uno dei possibili percorsi.
%            \item \textbf{Merge}: rappresentato da un rombo vuoto, è simile alla join. Differisce per il fatto che unisce più possibili elaborazioni non parallele ma in alternativa tra esse, porvenienti da uno o più branch.
%            \item \textbf{Pin parametro}: rappresentati da box, sono parametri che rappresentano risorse prodotte da azioni e consumate da altre azioni.
%            \item \textbf{Nodo finale}: rappresentato da un pallino pieno circondato da un cerchio, indica il termine dell'attività con successo.
%            \item \textbf{Nodo di fine flusso}: rappresentato da un cerchio con una croce, non termina l'attività.\par
%                Viene usata per casi speciali (eccezione, ramo del branch\dots).
%        \end{itemize}
%        Ogni attività può comporre un'azione. In tal caso si tratta di una sotto attività, e viene indicata con un simbolo a forca e da un rettangolo esterno con il nome dell'attività che ne rappresenta le azioni dall'input fino all'output.\par
%        Usiamo inoltre i seguenti costrutti:
%        \begin{itemize}
%            \item \textbf{Swimlanes}: sono rappresentate da riquadri che suddividono la responsabilità delle azioni presenti nelle attività.\par
%                Le azioni possono far capo a più swimlanes, per esempio l'azione di merge.
%            \item \textbf{Segnali}: indicano eventi provenienti da processi esterni.\par
%            Sono indicati in modo diverso a seconda dell'evento scatenante, che può essere dei seguenti tipi:
%            \begin{itemize}
%                \item \textbf{Eventi esterni}: l'evento generato viene rappresentato da un rettangolo con un lato a punta uscente, mentre l'azione che attende l'evento viene rappresentata con un rettangolo con un lato a punta entrante.
%                \item \textbf{Eventi temporali}: viene rappresentato con una clessidra e ne viene indicato il tempo di ripetizione.\par
%                    Può trovarsi all'inizio del flusso, sostituendo il nodo iniziale, per indicare che un'attività verrà eseguita ogni volta che l'evento temporale consuma il tempo indicato.
%            \end{itemize}
%        \end{itemize}
%        Per indicare azioni che si ripetono su più elementi, ad esempio su una lista di elementi, usiamo le regioni di espansione.
%        Le indichiamo con un rettangolo tratteggiato ad angoli arrotondati, e rettangoli piccoli presenti sui lati di inizio e fine regione, che rappresentano le liste di elementi processati.\par
%        Le frecce di entrata e uscita indicano in quale verso viene svolta l'attività che include la regione di espansione.

		%\subparagraph{Semantica}
		%Ogni diagramma inizia con uno stato iniziale segnato con un pallino nero, ogni transizione è una freccia....


		\subparagraph{Diagrammi di sequenza}\label{PP:Sviluppo:DiagrammiSequenza}
		Per i diagrammi di sequenza utilizziamo lo strumento \gloss{Draw.io} e il linguaggio UML 2.0.\par
        Usiamo questi diagrammi per descrivere come la collaborazione tramite messaggi di un gruppo di oggetti realizza un comportamento.\par
        Essi mostrano come gli oggetti interagiscono nel tempo, leggendo il diagramma dall'alto al basso.\par
        I principali costrutti usati sono:
        \begin{itemize}
            \item \textbf{Partecipanti}: rappresentati da un rettangolo contenente il nome dell'entità (spesso coincide col nome di una classe) e da una barra di attivazione (rettangolo che si prolunga per tutta la durata in cui l'entità è attiva), descrivono l'entità che detiene il flusso nel caso d'uso.
            \item \textbf{Messaggi}: rappresentano le operazioni chiamate tra le entità e i dati scambiati.\par
            Sono di diverse tipologie:
            \begin{itemize}
                \item \textbf{Sincroni}: rappresentati da una freccia piena con il nome del messaggio ed eventuali parametri tra parentesi tonde, descrivono la chiamata di un messaggio in cui l'entità chiamante attende la risposta dall'entità chiamata.
                \item \textbf{Asincroni}: rappresentati da una linea direzionata con il nome del messaggio ed eventuali parametri tra parentesi tonde, descrivono la chiamata di un messaggio in cui l'entità chiamante non attende la risposta dall'entità chiamata.
                \item \textbf{Ritorno}: rappresentati da una linea tratteggiata direzionata, indicano un messaggio di ritorno che risponde a un precedente messaggio di chiamata.
                \item \textbf{Creazione}: rappresentati da una linea tratteggiata direzionata e dalla notazione <<create>>, indicano la creazione di una nuova entità da parte dell'entità chiamante.
                \item \textbf{Distruzione}: rappresentati da una freccia piena e dalla notazione <<destroy>>, indicano la distruzione di un'entità da parte dell'entità chiamante.
            \end{itemize}
        \end{itemize}
        Per descrivere i cicli e le condizioni vengono utilizzati frame di interazione, rappresentati con un rettangolo che circonda i messaggi e le barre di attivazione coinvolte, con una label per indicare il tipo di frame, e da una guardia tra parentesi quadre nell'entità che ne scatena l'inizio.
        Vi sono i seguenti tipi di frame di interazione:
        \begin{itemize}
            \item \textbf{Alt}: più frame in alternativa, si sceglie in base alla guardia.
            \item \textbf{Opt}: opzionale, in base alla guardia si esegue o meno il frame.
            \item \textbf{Par}: parallelo, frame eseguiti in parallelo.
            \item \textbf{Loop}: ciclo eseguito più volte in base alla guardia.
            \item \textbf{Region}: regione critica eseguibile da un thread alla volta.
            \item \textbf{Ref}: l'interazione è definita in un altro diagramma.
            \item \textbf{Sd}: rachiude un diagramma di sequenza intero.
        \end{itemize}
        I diagrammi di sequenza sono inoltre utili per modellare la collaborazione tra entità.\par
        In caso di controllo centralizzato vi sarà un'entità che gestisce i messaggi verso tutte le altre, mentre in caso di controllo distribuito ogni entità avrà compiti ben delineati, quindi avrà la responsabilità della chiamata dei messaggi verso le altre entità coinvolte.\par
        Cerchiamo di usare per quanto possibile la modellazione a controllo distribuito, per non dare troppe responsabilità a una singola entità che diventerebbe il punto critico dell'architettura.

        \subparagraph{Architettura} \label{PP:progettazione:architettura}
        L'architettura può essere considerata la ``strategia'' che si occupa della parte più esterna del software. L'architettura si deve occupare di come si relazionano i vali elementi del software, non come questi sono formati. Anche l'architettura deve essere costruita secondo una best practise, che può cambiare in base al tipo di software che deve essere sviluppato. \par
        Un'architettura non si inventa ma si sceglie, e tra le più utilizzate troviamo:
        \begin{itemize}
            \item \textbf{Layer}: architettura che rispecchia la struttura di un'azienda e che vede il software sviluppato in più livelli disposti uno sopra l'altro. Un livello è dipendente esclusivamente da quello sottostante e comunica con esso. Generalmente i livelli sono Presentation layer, Business layer, Persisten layer e Database layer.
            \item \textbf{Event-driven}: architettura utile per la creazione di software che lavorano con messaggi asincroni elaborati in modo indipendente. Quest'architettura può essere sviluppata secondo la Mediator topology dove i messaggi vengono inseriti in un ``contenitore'' e smistati attraverso un apposito ``mediator'', oppure secondo la Broker topology dove i messaggi viaggiano attraverso un \gloss{broker} entrando ed uscendo dai vari canali.
            \item \textbf{Microservizi}: architettura usata per quei software destinati a possedere un incremento costante e controllato. Il software viene diviso in moduli indipendenti tra loro che comunicano verso l'esterno attraverso \gloss{API REST}. I moduli al loro interno sono costruiti attraverso un'architettura a Layer.
        \end{itemize}

        \subparagraph{Design Pattern}\label{StrumentiDP}
        I \gloss{design pattern} aiutano a creare le singole parti di un software in base ai compiti che queste hanno. Dato che un design pattern non è altro che una buona pratica di sviluppo, non è scontato che la loro presenza implichi una buona struttura del software, perciò è consigliato non abusarne. \par
        I design pattern si dividono in tre tipologie approfonditi in \S\ref{rifinfo} ai punti 25, 26, 27 e 28:
        \begin{itemize}
            \item \textbf{Strutturali}: aiutano ad organizzare la struttura delle classi favorendo la loro comunicazione attraverso interfacce. Questi sono l'Adapter, il Decorator il Façade e il Proxy.
            \item \textbf{Creazionali}: aiutano a dividere gli oggetti dalla loro costruzione e implementazione favorendo l'\gloss{information hiding}. Questi sono il Singleton, il Builder, e l'Abstract Factory.
            \item \textbf{Comportamentali}: applicabili nel momento in cui un componente deve eseguire una specifica funzione per cui il design pattern è stato costruito. Questi sono il Command, l'Iterator, l'Observer, lo Strategy e il Template Method.
            \item \textbf{Architetturali}: utili per strutturare il software con una visione ad un livello più alto degli altri design pattern, ma non alto come la visione per stabilire l'architettura software. Questi sono il Dependency Injection e i Model-View pattern.
        \end{itemize}

		%\subparagraph{Semantica}
		%Essendo il diagramma di sequenza composto da una serie di scelte già decise è molto utile ai fini di un chiaro utilizzo la decisione di una serie di partecipanti. La lettura del diagramma avviene dall’alto verso il basso....


		\paragraph{Qualità}\label{PP:Sviluppo:QualitàProgettazione}
		Per garantire una progettazione che rispetti gli standard di qualità posti nel {\PdQd}, seguiamo le linee guida date dalle best practice.

        \subparagraph{Qualità dei diagrammi dei package}
        Evitiamo le dipendenze circolari tra le classi osservando le dipendenze tra i package. Ne consegue che vanno evitate le dipendenze circolari tra i package.

		\subparagraph{Qualità dei diagrammi delle classi}
		Teniamo gli attributi delle classi privati per quanto possibile.
        Evitiamo ove possibile di usare attributi modificabili dai metodi delle classi, in quanto ostacolano la scrittura dei test ed è meno comprensibile la responsabilità sull'attributo.\par
        Evitiamo le relazioni bidirezionali perché si crea confusione su quale classe ha la responsabilità sulla relazione.\par
        Minimizziamo le dipendenze tra le classi in modo da rendere il diagramma più comprensibile e cerchiamo di usare le relazioni di dipendenza debole rispetto alle dipendenze forti, per favorire il riuso del codice ed evitare modifiche inutili e a cascata.

%		\paragraph{Qualità dei diagrammi di attività}
%		Poiché descrivono gli aspetti dinamici dei casi d'uso, non devono risultare eccesivamente complessi, ma descrivere quanto riportato da casi d'uso e requisiti.\par
%        Li usiamo in modo da aggiungere comprensibilità, non per toglierne.

		\subparagraph{Qualità dei diagrammi di sequenza}
		Andando più nel dettaglio rispetto ai diagrammi di attività, i diagrammi di sequenza vanno scritti in modo da rispettare quanto descritto dai diagrammi di attività e delle classi.\par
        Per modellare la logica di controllo è meglio usare i diagrammi di attività perché di più semplice lettura.

		%\paragraph{Qualità dei diagrammi dei casi d'uso}
		%Contenuto

		%manuale utente da presentare in RQ, quindi da fare più avanti
		%\subsubsection{Produzione del manuale utente}

        \subparagraph{Qualità dell'architettura}\label{QualitaArchitettura}
        L'architettura è una delle scelte fondamentali da fare durante il processo della progettazione, perché essa stabilirà poi la natura dell'intero software.
        La scelta di un'architettura ha lo scopo di:
        \begin{itemize}
            \item ridurre l'accoppiamento
            \item ridurre la duplicazione di codice
            \item semplificare lo sviluppo
            \item semplificare il mantenimento del software
        \end{itemize}
        Bisogna dunque capire quale architettura si addice di più ai propri scopi in base alle qualità e ai difetti di ognuna. \par
        Gli aggettivi che definiscono un'architettura sono:
        \begin{itemize}
            \item \textbf{Agilità}: con che facilità e velocità riesco a modificare il software.
            \item \textbf{Rilasciabile}: con che facilità riesco ad aggiornare o installare il software.
            \item \textbf{Verificabile}: con che facilità riesco a creare ed eseguire i vari tipi di test.
            \item \textbf{Performance}: con che velocità riesco ad ottenere le informazioni richieste.
            \item \textbf{Scalabilità}: con che facilità riesco a gestire la crescita del numero di utenti.
            \item \textbf{Sviluppabile}: con che facilità riesco a sviluppare il software applicando tale architettura.
        \end{itemize}

        Analizzando le architetture in \S\ref{PP:progettazione:architettura}, le loro qualità e difetti sono:
        \begin{itemize}
            \item \textbf{Layer}:
                \begin{itemize}
                    \item \textbf{Agilità}: poca, dato che il software tende a diventare un monolite.
                    \item \textbf{Rilasciabile}: poca, dato che ad ogni aggiornamento tutto il software deve essere reinstallato.
                    \item \textbf{Verificabile}: buona, dato che ottenere il \gloss{Mock} dei vari livelli non è complesso.
                    \item \textbf{Performance}: poca, dato che un'informazione, per essere recuperata, deve passare per i vari livelli.
                    \item \textbf{Scalabilità}: poca, dato che la grande granularità rende laboriosa l'aggiunta di utenti.
                    \item \textbf{Sviluppabile}: buona, dato che è un'architettura molto conosciuta e che rispecchia la struttura di un'azienda.
                \end{itemize}
            \item \textbf{Event-driven}:
                \begin{itemize}
                    \item \textbf{Agilità}: buona, dato che le varie componenti sono tutte isolate.
                    \item \textbf{Rilasciabile}: buona, dato che si può installare un componente alla volta.
                    \item \textbf{Verificabile}: poco, dato i molti tipi di messaggi da generare per eseguire i test.
                    \item \textbf{Performance}: buona, dato che i messaggi sono asincroni.
                    \item \textbf{Scalabilità}: buona, dato che si posseggono canali separati che possono aggiungere facilmente.
                    \item \textbf{Sviluppabile}: poca, dato che coi messaggi asincroni bisogna lavorare con \gloss{interfacce} che non possono cambiare nel tempo.
                \end{itemize}
            \item \textbf{Microservizi}:
                \begin{itemize}
                    \item \textbf{Agilità}: buona, dato che ogni microservizio è autonomo.
                    \item \textbf{Rilasciabile}: buono, perché i microservizi possono essere installati singolarmente.
                    \item \textbf{Verificabile}: buono, perché i microservizi lavorano in modo autonomo.
                    \item \textbf{Performance}: poca, dato che il numero di chiamate delle API REST può essere alto.
                    \item \textbf{Scalabilità}: buona, dato che i microservizi possono essere aggiunti velocemente.
                    \item \textbf{Sviluppabile}: buona, dato che i microservizi vengono sviluppati da gruppi di persone poco numerosi e dunque più facilmente organizzati.
                \end{itemize}
        \end{itemize}

        \subparagraph{Qualità dei design pattern} \label{PP:progettazione:designPattern}
        L'uso dei design pattern non deve essere abusato per evitare complessità inutile nel software. Per questo la loro applicazione deve seguire tali step per comprendere se applicarne uno o meno:
        \begin{enumerate}
            \item Comprendere lo scopo del componente
            \item Analizzarne la complessità strutturale
            \item Elencare i bisogni di tale componente in termini di struttura del software
            \item Vedere se un design pattern strutturale è utile per semplificare la struttura del componente
            \item Vedere se la creazione del componente può essere semplificata con l'uso di un design pattern creazionale
            \item Vedere se la funzione del componente corrisponde alla funzionalità descritta da un design pattern comportamentale, nel caso vedere se la sua applicazione rende più flessibile il componente
        \end{enumerate}
        
        \paragraph{Applicazione} \label{PP:progettazione:applicazione}
        Per effettuare una buona progettazione è utile seguire una procedura prestabilita, in modo tale da non rendere il risultato confuso o non tracciabile. \'E bene ricordare che all'interno della progettazione non si sviluppa codice, tale passaggio avviene durante il processo di codifica che segue il quello di progettazione. \par
        La progettazione ha il compito di far sintesi dei requisiti, provenienti dal processo di analisi, attraverso il software applicando prima una strategia top-down e successivamente bottom-up. I passi da seguire durante la fase di top-down sono i seguenti:
        \begin{enumerate}
            \item Analizzare nell'insieme i requisiti del prodotto finale in termini di qualità architetturali (performance, scalabilità, ecc\dots)
            \item Individuare l'architettura che più si addice al software da realizzare
            \item Rappresentare l'architettura attraverso un diagramma. Questo mostrerà solo la struttura del software ad alto livello
        \end{enumerate}
        Ora per ogni requisito troviamo la giusta struttura seguendo una strategia bottom-up:
        \begin{enumerate}
            \item Scegliere un requisito proveniente dal processo di analisi
            \item Pensare a come potrebbe essere soddisfatto attraverso il software
            \item Analizzare se per tale requisito esistono delle tecnologie preesistenti da poter usare
            \item Dopo aver compreso il ruolo del componente software, pensare a come questo possa costruire i suoi oggetti o come si deve comportare
            \item Analizzare se un design patter può semplificare la struttura o il comportamento del componente precedentemente ideato ed applicarlo
            \item Riportare la struttura del componente in UML2.0
        \end{enumerate}
        Dopo aver preparato i diagrammi dei vari componenti, osservando l'architettura scelta, studiare come questi possono essere uniti per garantire coesione, flessibilità, manutenibilità, modularità e affidabilità.

        \newpage

		\subsubsection{Codifica}\label{PP:Sviluppo:Codifica}

		\paragraph{Scopo}
		La presente sezione ha lo scopo di normare l'attività di codifica che svolgeremo nel corso della realizzazione del progetto \progetto, per
		evitare qualsiasi tipo di inconsistenza e rendere il codice il quanto più omogeneo possibile.

		Il progetto sarà sviluppato utilizzando il linguaggio \gloss{Python}.
		Per le norme di stile relative a questo linguaggio, seguiremo il PEP 8\footnote{Riferirsi alla voce
		% ``PEP 8''
		32
		  in \S\ref{rifinfo}},
		lo standard Python che definisce lo stile da seguire nella codifica e in attività correlate ad essa.

        \paragraph{Intestazione}\label{PP:Sviluppo:Codifica:Intestazione}
		Ogni sorgente Python conterrà la seguente intestazione:
		\begin{verbatim}
			"""
			File:	<nomefile.estensione>
			Data creazione: <YYYY-MM-DD>

			<descrizione>

			Licenza:	<nome licenza>
			Versione:	<X.Y.Z>
			Creatore:	<nome cognome: email>
			Autori:
				<nome cognome: email>
				<nome cognome: email>
				....
			"""
		\end{verbatim}

		\paragraph{Formattazione}\label{PP:Sviluppo:Codifica:Formattazione}
		Viene utilizzato uno spazio per separare simboli e identificatori.
		\lstinputlisting{py/format.py}


		\paragraph{Convenzioni di nominazione}\label{PP:Sviluppo:Codifica:ConvenzioniDiNominazione}
		\begin{itemize}
			\item Per i nomi delle classi, viene usato \texttt{PascalCase}\footnote{Riferirsi alla voce
			% ``Naming convention''
			15
			  in \S\ref{rifinfo}}
			\item Per le costanti, viene usato \texttt{MACRO\_CASE}
			\item Per denominare tutto il resto, ad esempio variabili e metodi, si usa \texttt{snake\_case}
		\end{itemize}

		Inoltre, tutti gli identificativi devono avere dei nomi significativi, relativi al contesto e alla loro utilità.
\begin{lstlisting}[language=Python]
uscita = True		# Si
a = True			# No

count_match = 0		# Si
b = 0				# No

def somma(x, y):	# Si, x e y sono concessi per il chiaro contesto matematico
	return x + y
def foo(a, b):		# No
	return a + b
\end{lstlisting}

        \paragraph{Indentazione}\label{PP:Sviluppo:Codifica:Indentazione}
		Per l'indentazione, come da PEP 8, vanno usano 4 spazi. L'IDE utilizzato dovrà essere configurato in modo che, premendo il
		tasto TAB, verranno generati 4 spazi.

		\paragraph{Stringhe}\label{PP:Sviluppo:Codifica:Stringhe}
		Preferire l'uso del carattere di apice singolo (') per circondare le stringhe. Usare il doppio apice (") solo per aumentare la
		leggibilità in caso sia presente nella stringa un apice singolo, o per le stringhe di documentazione (circondate da tripli apici doppi).\par
		Per ottenere stringhe formattabili con parametri, usare le f-stringhe introdotte con Python 3.6, o, in caso di migliore leggibilità, usare la funzione \texttt{format()}.

\begin{lstlisting}[language=Python]
stringa = 'una stringa'
def foo(x):
	"""Stringa di documentazione"""
	pass
f_stringa = f'{stringa} parametrizzata!'
\end{lstlisting}

        \paragraph{Lunghezza massima delle righe}\label{PP:Sviluppo:Codifica:LunghezzaMassimaDelleRighe}
		Le righe di codice devono avere una lunghezza massima di 79 caratteri. Le righe di documentazione relative ad esempio a un metodo,
		invece, non devono contenere più di 72 caratteri.
		A tal fine, vengono divisi in più righe le istruzioni che superano il limite massimo di caratteri, per migliorare la leggibilità.

		\begin{lstlisting}[language=Python]
with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
	file_2.write(file_1.read())
		\end{lstlisting}


		\paragraph{Lunghezza massima di metodi e funzioni}\label{PP:Sviluppo:Codifica:LunghezzaMassimaDeiMetodi}
		Il numero massimo di righe per ogni metodo o funzione viene fissato a 50 linee di codice, numero necessario ad occupare un'intera
		schermata su un comune IDE. Funzioni più lunghe di 50 righe sono quasi sicuramente sintomo di una funzione che svolge troppi compiti,
		che sarebbe spacchettabile in più funzioni.

		\paragraph{Parametri delle funzioni}\label{PP:Sviluppo:Codifica:ParametriDelleFunzioni}
		Per i parametri delle funzioni, usare dei nomi esplicativi se il numero dei parametri non supera i 6. Altrimenti, preferire l'uso di liste
		arbitrarie di parametri e l'uso di coppie chiavi-valori. Documentare, di conseguenza,
		i nomi dei parametri che l'operatore ** (per le coppie chiave-valore) si aspetta, e sollevare una eccezione appropriata in caso si ottenga una chiave
		inaspettata.
\begin{lstlisting}[language=Python]
def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments:
        print(arg)
    print("-" * 40)
    for kw in keywords:
        print(kw, ":", keywords[kw])
\end{lstlisting}

        \paragraph{Complessità ciclomatica}\label{PP:Sviluppo:Codifica:ComplessitàCiclomatica}
		Va evitato il più possibile l'annidamento di più strutture di controllo. Per questo, stare sotto i tre livelli di annidamento è una buona
		prassi che semplifica leggibilità e \gloss{debugging} e va rispettata il più possibile.


		\paragraph{Ereditarietà}\label{PP:Sviluppo:Codifica:Ereditarietà}
		Evitare l'ereditarietà tra classi concrete. È invece possibile che una classe derivi da un'altra se quest'ultima è
		un'\gloss{interfaccia} o una classe astratta.

		Viene adottato, per ovviare all'ereditarietà tra classi concrete, il principio di ``Composition over inheritance''\footnote{Riferirsi alla voce
		%``Composition over inheritance''
		29
		 in \S\ref{rifinfo}.}.

		Va limitato, ove possibile, la dipendenza tra classi concrete: dipendere quindi sulle astrazioni (interfacce e classi astratte).

        \paragraph{Commenti}\label{PP:Sviluppo:Codifica:Commenti}
		Il \Progr\ è tenuto ad inserire commenti ove ritiene che questo possa migliorare la leggibilità del codice. Per contro, i commenti vanno
		omessi dove il codice è auto esplicatorio.\par
		Per inserire un commento, far seguire al simbolo di commento (\texttt{\#}) uno spazio, e iniziare con una lettera maiuscola (e.g.
		\texttt{\#\ Cerca il match del parametro x nella lista}). In caso di commento su più righe, solo la prima riga va iniziata con carattere
		maiuscolo.

        \paragraph{Documentazione dei metodi}\label{PP:Sviluppo:Codifica:DocumentazioneDeiMetodi}
        Ogni metodo è necessario che sia il più chiaro possibile. Oltre che a non dover avere una lunghezza non troppo elevata (visibile in \S\ref{PP:Sviluppo:Codifica:LunghezzaMassimaDeiMetodi}), un metodo deve essere anche ben documentato, indicando il tipo dei parametri e quelli delle variabili ritornate.

        La documentazione di un metodo deve avere la seguente forma:
\begin{verbatim}
def complex(real=0.0, imag=0.0):
    """
    Form a complex number.

    Keyword arguments:
    real -- the real part (default 0.0)
    imag -- the imaginary part (default 0.0)

    Return arguments:
    complex_zero -- the merge of real and imag
    """
    if imag == 0.0 and real == 0.0:
    return complex_zero
    ...
\end{verbatim}

        \paragraph{Metriche per la codifica}\label{PP:Sviluppo:MetricheCodifica}
        Tutti i paragrafi sulle norme di codifica precedentemente descritte devono corrispondere ad una metrica in modo tale da tenere traccia dei cambiamenti nella qualità dei prodotti contenenti codice in Python.

        La denominazione delle metriche è descritta in \S\ref{Classificazione metriche}.

        Le seguenti metriche possiedono le seguenti regole:
        \begin{itemize}
            \item Il titolo del metodo sottintende prima del loro inizio ``numero di/dei'' (e.g. ``File senza intestazione'' è inteso come ``numero di file senza intestazione'')
            \item Il termine ``righe'' intente ``righe di codice''
            \item I termini ``metodi'', ``classi'', ``righe'' o ``variabili'' appartengono tutti al campo semantico dei linguaggi di programmazione
        \end{itemize}

        Le metriche inerenti alla codifica sono riferite ad una specifica regola di codifica:
        \begin{itemize}
            \item \textbf{MPS005 File senza intestazione}: \S\ref{PP:Sviluppo:Codifica:Intestazione}.
            \item \textbf{MPS006 Righe non formattate}: \S\ref{PP:Sviluppo:Codifica:Formattazione}.
            \item \textbf{MPS007 Nomi di variabili, metodi e classi non normati}: \S\ref{PP:Sviluppo:Codifica:ConvenzioniDiNominazione}.
            \item \textbf{MPS008 Righe non indentate}: \S\ref{PP:Sviluppo:Codifica:Indentazione}.
            \item \textbf{MPS009 Stringhe non normate}: \S\ref{PP:Sviluppo:Codifica:Stringhe}.
            \item \textbf{MPS010 Righe troppo lunghe}: \S\ref{PP:Sviluppo:Codifica:LunghezzaMassimaDelleRighe}.
            \item \textbf{MPS011 Metodi troppo lunghi}: \S\ref{PP:Sviluppo:Codifica:LunghezzaMassimaDeiMetodi}.
            \item \textbf{MPS012 Metodi con troppi parametri}: \S\ref{PP:Sviluppo:Codifica:ParametriDelleFunzioni}.
            \item \textbf{MPS013 Metodi con troppa complessità ciclomatica}: \S\ref{PP:Sviluppo:Codifica:ComplessitàCiclomatica}.
            \item \textbf{MPS014 Classi che implementano classi concrete}: \S\ref{PP:Sviluppo:Codifica:Ereditarietà}.
            \item \textbf{MPS015 Commenti non normati}: \S\ref{PP:Sviluppo:Codifica:Commenti}.
            \item \textbf{MPS016 Metodi non documentati}: \S\ref{PP:Sviluppo:Codifica:DocumentazioneDeiMetodi}.
        \end{itemize}

        \subparagraph{MPS005 File senza intestazione}
        Ogni file deve possedere l'intestazione definita per avere subito l'idea di cosa questo contiene.

        \textbf{Metrica:} il numero di file che non possiedono l'intestazione definita.

        \subparagraph{MPS006 Righe non formattate}
        Il codice, per essere più leggibile deve contenere delle adeguate spaziature.

        \textbf{Metrica:} numero adeguato di spaziature non eseguite.

        \subparagraph{MPS007 Nomi di variabili, metodi e classi non normati}
        I nomi delle variabili o i titoli delle classi o dei metodi devono seguire delle specifiche regole per essere il più possibile parlanti.

        \textbf{Metrica:} numero di nomi di variabili o di titoli di metodi o classi che non rispettano le norme stabilite.

        \subparagraph{MPS008 Righe non indentate}
        Per rendere più chiaro l'inizio e la fine di un ciclo, metodo, classe
        o di una condizione è obbligatorio eseguire le dovute tabulazioni.

        \textbf{Metrica:} numero di tabulazioni non eseguite.

        \subparagraph{MPS009 Stringhe non normate}
        In Python le stringhe possono essere create in vari modi, secondo le norme noi ne scegliamo una in particolare.

        \textbf{Metrica:} numero di volte in cui le stringhe non vengono create nel modo stabilito.

        \subparagraph{MPS010 Righe troppo lunghe}
        Perché del codice sia leggibile, le sue istruzioni non possono essere troppo lunghe. Per questo è stata stabilita una soglia massima di caratteri per istruzione.

        \textbf{Metrica:} numero di righe di codice che superano i 79 caratteri.

        \subparagraph{MPS011 Metodi troppo lunghi}
        Un metodo trasversale per impedire che un metodo compia troppe azioni è quello di limitarne la lunghezza.

        \textbf{Metrica:} il numero di metodi o funzioni che sono più lunghi di 50 righe di codice.

        \subparagraph{MPS012 Metodi con troppi parametri}
        Limitare il numero di parametri in un metodo è un altro modo per evitare di caricarlo di troppe mansioni.

        \textbf{Metrica:} il numero di metodi con più di 6 parametri.

        \subparagraph{MPS013 Metodi con troppa complessità ciclomatica}
        Un metodo che possiede molte istruzioni condizionali o cicli è difficile da testare e nel peggiore dei casi lento da eseguire. Perciò è buona norma limitare l'uso di queste istruzioni.

        \textbf{Metrica:} numero di metodi che possiedono più di 3 cicli annidati.

        \subparagraph{MPS014 Classi che implementano classi concrete}
        L'ereditarietà tra classi deve essere evitata perché la presenza di dipendenze tra più componenti ne ostacola la modifica e la verifica.

        \textbf{Metrica:} numero di classi che ereditano un'altra classe concreta.

        \subparagraph{MPS015 Commenti non normati}
        I commenti, per essere significativi devono essere scritti seguendo le norme indicate.

        \textbf{Metrica:} numero di commenti che seguono le norme indicate.

        \subparagraph{MPS016 Metodi non documentati}
        La documentazione dei metodi, come per i file, serve per far saltare subito all'occhio il loro compito. La loro documentazione deve seguire le norme precedentemente indicate.

        \textbf{Metrica:} numero di metodi che non possiede una documentazione a norma.

        \subsubsection{Strumenti di base}\label{PP:Sviluppo:Strumenti}

	    \paragraph{Ambiente di sviluppo}\label{PP:Sviluppo:Strumenti:AmbienteSviluppo}
	    Nei paragrafi successivi vengono riportate le componenti software utilizzate da ogni membro del team per lo sviluppo del progetto.


	    \subparagraph{Sistema operativo}\label{PP:Sviluppo:Strumenti:AmbienteSviluppo:SistemaOperativo}
	    Abbiamo deciso di usare, come sistema operativo, GNU/Linux, in particolare una qualsiasi distribuzione basata su Ubuntu 18.04.

	    \subparagraph{IDE}\label{PP:Sviluppo:Strumenti:AmbienteSviluppo:IDE} % NOTE: controllare la sezione relativa a VSC sui processi di supporto
		Gli IDE principali scelti per lo sviluppo di codice Python sono
		{PyCharm}\footnote{Riferirsi alla voce
		%``Pycharm''
		16
		 in \S\ref{rifinfo}} e
		{Visual Studio Code}\footnote{Riferirsi alla voce
		% ``Visual Studio Code''
		23
		  in \S\ref{rifinfo}}.
		Il primo è proprietario e supportato dal team di IntelliJ, il secondo è un progetto \gloss{open source} di Microsoft, che ha
		per questo il supporto della comunità open source.\par
		Entrambi offrono la maggior parte dei vantaggi utili al processo di sviluppo di \progetto, tra cui:
		\begin{itemize}
			\item Highlighting del codice per una lettura agevole
			\item Pylint, un \gloss{linter} per Python per l'analisi in tempo reale della qualità del codice
			\item Debugging
			\item Supporto a una miriade di plugin esterni
		\end{itemize}

		\begin{figure}[H]
			\includegraphics[width=\textwidth]{img/pycharm.png}
			\caption{Interfaccia grafica di PyCharm}
		\end{figure}
