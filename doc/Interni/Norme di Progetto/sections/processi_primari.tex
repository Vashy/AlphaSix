\section{Processi primari}\label{ProcessiPrimari}

    \subsection{Processo di fornitura}\label{PP:Fornitura}	%istanziare Management Process, Infrastructure Process e Improvement Process

        \subsubsection{Scopo}\label{PP:Fornitura:Scopo}
		La sezione corrente ha lo scopo di riportare le attività principali che impegneremo ad attuare al fine di
		diventare \gloss{fornitori} per la proponente \II.

		\subsubsection{Ricerca delle tecnologie}
		Ognuno di noi approfondirà la propria conoscenza su tecnologie e \gloss{framework} vari, in modo da discutere insieme quali sono
		quelle di interesse comune e di utilità per il progetto. Questo prevede poi l'auto-formazione di quelle scelte in comune accordo
		per acquisirne una buona padronanza.

		\subsubsection{Normazione} % TODO
		% L’Amministratore apporta incrementi all’insieme di regole che ogni componente del gruppo deve seguire durante lo svolgimento delle
		% attività e dei compiti a lui assegnati. Con il procedere del progetto, si acquisiscono nuove conoscenze o si incontrano difficoltà
		% che potrebbero richiedere la modifica di queste regole....

        \subsubsection{Studio di fattibilità}\label{PP:Fornitura:SdF}
        In quest'attività viene prodotto il documento \Doc{\SdFv} al fine di analizzare ogni \gloss{capitolato} e scegliere quale contratto accettare.
        Nello specifico, il documento in ogni sezione contiene:
        	\begin{itemize}
        		\item \textbf{Descrizione generale}: breve descrizione del capitolato.
        		\item \textbf{Obiettivo finale}: obiettivo da raggiungere.
        		\item \textbf{Tecnologie coinvolte}: elenco delle tecnologie direttamente coinvolte esplicitate nel capitolato.
        		\item \textbf{Valutazione conclusiva}: giudizio finale del team di sviluppo.
        	\end{itemize}

        \subsubsection{Preparazione in vista della revisione}
		In questa attività prepariamo tutto il materiale necessario per il buon superamento della revisione:
		\begin{itemize}
			\item I vari documenti, i verbali e la lettera di presentazione per quanto riguarda la documentazione in ingresso
			\item I diagrammi dei package e il codice necessari per la realizzazione del \gloss{Proof of Concept}
			\item Le diapositive per l'esposizione
		\end{itemize}

    \subsection{Processo di sviluppo}\label{PP:Sviluppo}

		\subsubsection{Scopo}\label{PP:Sviluppo:Scopo}
		Lo sviluppo consiste nell'affrontare le attività volte a produrre il software richiesto dal proponente.
		Per una corretta implementazione di questo \gloss{processo}, è necessario:
		\begin{itemize}
			\item Fissare degli obiettivi di sviluppo
			\item Realizzare un prodotto che sia conforme a:
			\begin{itemize}
				\item \gloss{Requisiti} definiti dal proponente
				\item Test definiti dalle norme di \gloss{qualità}
			\end{itemize}
		\end{itemize}
		Lo standard ISO/IEC 12207:1995\footnote{Riferirsi alla voce ``ISO/IEC 12207'' in \S\ref{rifnorma}} definisce il processo di
		sviluppo quel processo contenente tutte le attività relative al prodotto finale, quali:
		\begin{itemize} % [noitemsep]
			\item Analisi dei requisiti
			\item Progettazione
			\item Codifica
			\item Integrazione ed installazione
		\end{itemize}


        \subsubsection{Analisi dei requisiti}\label{PP:Sviluppo:AdR}
		Gli Analisti si occupano di redigere l'\Doc{\AdRv}, composta come segue:
		\begin{itemize}
			\item Descrizione generale del prodotto
			\item Modellazione concettuale del \gloss{sistema} tramite la definizione dei vari \gloss{casi d'uso}
			\item Classificazione e tracciamento dei requisiti
		\end{itemize}

		\paragraph{Denominazione dei requisiti}\label{PP:Sviluppo:AdR:DenominazioneRequisiti}
		Ogni requisito che è stato individuato durante l'analisi presenta il seguente identificativo univoco:
		\begin{center}
			\texttt{R[Numero][Tipo][Priorità]}
		\end{center}

		\begin{itemize}
			\item \textbf{R}: si riferisce a requisito.
		 	\item \textbf{Numero}: corrisponde ad un numero che cerca di seguire la struttura del documento ed è progressivo. Inizia da 1.
		 	\item \textbf{Tipo}: segnala la tipologia di requisito che può essere di:
		 	\begin{itemize}
		 		\item \textbf{F}: funzionalità, che ha a che vedere con le funzionalità del sistema software.
		 		\item \textbf{Q}: qualità, che riguarda tecniche ad hoc.
		 		\item \textbf{V}: vincolo, proposto da \II.
		 	\end{itemize}
	 		\item \textbf{Priorità}: indica il grado di urgenza per il soddisfacimento di un requisito, come:
	 		\begin{itemize}
	 			\item \textbf{0}: opzionale, di grado basso e solo marginalmente utile.
	 			\item \textbf{1}: desiderabile, di medio livello quindi non strettamente necessario ma che dà valore aggiunto.
	 			\item \textbf{2}: obbligatorio, di grado alto quindi irrinunciabile per il \gloss{committente} e impossibile da tralasciare.
	 		\end{itemize}
		\end{itemize}

		Esempio: \texttt{R2Q1} indica il secondo requisito di qualità ed è desiderabile.


		\paragraph{Metriche sui requisiti}\label{MetricheAdR}
		Dato che non è fisso il numero dei requisiti di un progetto, abbiamo scelto una serie di metriche dove il valore ottimale da raggiungere è sempre uguale, lo zero. Abbiamo anche scelto di contare il numero di requisiti non soddisfatti invece che il contrario. Lo stesso ragionamento è valido per quanto	riguarda i rischi che possono verificarsi nel corso del progetto.
		Gli obiettivi che si vogliono raggiungere attraverso tali metriche possono essere stabiliti solo a progetto concluso.
		
		La denominazione delle metriche è descritta in \S\ref{Classificazione metriche}.
		
		\subparagraph{MPR005 Requisiti obbligatori non soddisfatti}
		Per adempiere completamente alla richiesta del cliente, ci serve individuare tutti i requisiti presenti nella sua richiesta, impliciti, espliciti, diretti e derivati. Alcuni sono imprescindibili, detti obbligatori, e il loro soddisfacimento determina la buona riuscita del progetto.
		
		\textbf{Metrica}: numero dei requisiti obbligatori non soddisfatti.
		
		\subparagraph{MPR006 Requisiti desiderabili non soddisfatti}
		I requisiti desiderabili non sono necessari, ma offrono un valore aggiunto al progetto.
		
		\textbf{Metrica}: numero dei requisiti desiderabili non soddisfatti.
		
		\subparagraph{MPR007 Requisiti opzionali non soddisfatti}
		Tali requisiti dovranno essere adempiuti solo nel momento in cui tutti i requisiti obbligatori saranno soddisfatti.
		Possono essere concordati col cliente in corso d'opera.
		
		\textbf{Metrica}: numero dei requisiti opzionali non soddisfatti.
	

		\paragraph{Casi d'uso}\label{PP:Sviluppo:AdR:CasiUso}
		Un caso d'uso è una tecnica che identifica i requisiti funzionali descrivendo le interazioni tra il sistema di riferimento e un utente ad esso esterno.\\
		Ogni caso d'uso che si vuol descrivere presenta:
		\begin{itemize}
		 	\item \textbf{Codice}: per l'identificazione del tipo:
		 	\begin{itemize}
		 		\item \texttt{UC[Numero]}: per un caso principale (e.g. per il primo caso d'uso avremo \texttt{UC1}).
		 		\item \texttt{UC[Numero].[Numero]}: per un sotto caso (e.g. per il primo figlio del primo caso d'uso avremo \texttt{UC1.1}).
			\end{itemize}
		 	\item \textbf{Titolo}: denominazione del caso d'uso, possibilmente breve.
		 	\item \textbf{Attori primari}: tutti gli \gloss{attori} primari coinvolti.
		 	\item \textbf{Attori secondari}: opzionale, tutti gli attori secondari coinvolti.
		 	\item \textbf{Descrizione}: per spiegare più nel dettaglio le azioni che vengono compiute.
		 	\item \textbf{Precondizione}: per rappresentare lo stato del sistema nell'istante precedente.
		 	\item \textbf{Postcondizione}: per rappresentare lo stato del sistema l'istante successivo.
		 	\item \textbf{Scenario principale}: contenente la serie di azioni da compiere numerate nell'ordine in cui vengono compiute.
		 	\item \textbf{Estensioni}: opzionale, per azioni inerenti a scenari alternativi come d'eccezione o errore.
		\end{itemize}

		Vi possono essere al massimo tre livelli di annidamento, come nel seguente esempio:
		\begin{itemize}
			\item \texttt{UC1} identifica il caso d'uso con il numero 1
			\item \texttt{UC1.1} identifica il sottocaso 1 del caso d'uso 1
			\item \texttt{UC1.1.1} identifica il sottocaso 1 del caso d'uso 1.1
		\end{itemize}
		Per ogni livello i numeri partono da 1.

        \subsubsection{Progettazione}\label{PP:Sviluppo:Progettazione}
        La progettazione è l'attività svolta dai progettisti con il fine di dare una soluzione soddisfacente per tutti gli stakeholder coinvolti nel rispetto delle best practice e dei design pattern scelti, attraverso la descrizione dell'architettura del software.

		\paragraph{Obiettivi}\label{PP:Sviluppo:Progettazione:Obiettivi}
        Gli obiettivi dell'attività di progettazione sono:
        \begin{itemize}
			\item Definire l'architettura logica del prodotto.
			\item Organizzare le responsabilità di realizzazione.
			\item Garantire la qualità del prodotto finale.
		\end{itemize}
        

		\subsubsection{Diagrammi UML}\label{PP:Sviluppo:UML} %TODO: notare se da scrivere ora tutti o solo alcuni (classi - attività -sequenza)

		\paragraph{Diagrammi delle classi}\label{PP:Sviluppo:DiagrammiClassi}
		Per i diagrammi dei casi d'uso utilizziamo lo strumento \gloss{Draw.io} e il linguaggio \gloss{UML} 2.0.\\
        Questi diagrammi strutturali descrivono ad alto livello i tipi di oggetto presenti nel sistema e le relazioni che intercorrono tra essi.
		I diagrammi delle classi sono composti dalle seguenti proprietà:
		\begin{itemize}
			\item \textbf{Attributi}: rappresentano lo stato dell'oggetto. Presentano le caratteristiche:
			    \begin{itemize}
			        \item \textbf{Visibilità}: pubblica (+), privata(-) o protetta(\#) rispetto alle altre classi.
			        \item \textbf{Nome}: nome dell'attributo.
			        \item \textbf{Tipo}: tipo dell'attributo (intero, stringa\dots).
			        \item \textbf{Molteplicità}: numero di occorrenze dell'attributo (opzionale).
			        \item \textbf{Default}: valore di default dell'attributo (opzionale).
                    \item \textbf{Altro}: molteplicità\dots (opzionali)
			    \end{itemize}
			\item \textbf{Associazioni}: rappresentano legami tra classi.\\
                        Le rappresentiamo con linee continue orientate tra due classi, hanno un nome.
		\end{itemize}
        Nella parte bassa del rettangolo delle classi rappresentiamo le operazioni fornite dalla classe, composte da:
        \begin{itemize}
            \item \textbf{Visibilità}: come per gli attributi.
            \item \textbf{Nome}: nome dell'operazione.
            \item \textbf{Lista dei parametri}: parametri necessari all'operazione. Sono formati da:
            \begin{itemize}
                \item \textbf{Direzione}: indica se il parametro è in lettura (in), scrittura (out) o entrambi (inout). Opzionale, di default è in lettura.
                \item \textbf{Nome}: nome del parametro.
                \item \textbf{Tipo}: tipo del parametro.
                \item \textbf{Default}: valore di default del parametro (opzionale).
            \end{itemize}
            \item \textbf{Tipo di ritorno}: tipo ritornato dall'operazione.
        \end{itemize}
        Tra le classi rappresentiamo le seguenti relazioni di dipendenza:
        \begin{itemize}
            \item \textbf{Dipendenza}: rappresentata da una linea orientata tratteggiata, indica che una classe usa un'operazione fornita dalla classe puntata.
            %TODO: la mettiamo? \item \textbf{Associazione}: rappresentata da una linea continua semplice, indica che una classe possiede uno o più attributi (a seconda delle molteplicità indicate sulla linea) dell'altra, o viceversa.
            \item \textbf{Aggregazione}: rappresentata da un diamante vuoto seguito da una linea continua, indica che una classe (puntata dal diamante) possiede un'istanza di un'altra classe tra gli attributi. Tale istanza può essere condivisa.
            \item \textbf{Composizione}: rappresentata da un diamante pieno seguito da una linea continua, è come l'aggregazione ma in tal caso l'aggregato non è condiviso tra più istanze.
            \item \textbf{Generalizzazione}: rappresentata da una freccia vuota, indica che ogni classe che punta verso un'altra è anche un'istanza di essa (eredita metodi e attributi).
        \end{itemize}
        Vengono inoltre usati i seguenti costrutti:
            \begin{itemize}
                \item \textbf{Classi astratte}: il nome è indicato in corsivo, non possono essere istanziate. Presentano almeno un'operazione astratta (con il nome in corsivo) e possono avere attributi.\\
                Tali classi generalizzano altre classi che devono implementare le operazioni astratte per essere istanziate, altrimenti sono anch'esse astratte e generalizzano altre classi.
                \item \textbf{Interfacce}: Indicate da un pallino vuoto e una linea continua verso classi, presentano solamente le operazioni che vengono implementate dalle classi collegate con la linea.\\
                Possono essere indicate con un pallino vuoto e un semicerchio a destra per indicare che l'interfaccia viene usata da un componente in un punto qualsiasi (ritorno di un'operazione, attributo\dots).
            \end{itemize}
        
		

		\subparagraph{Semantica} %TODO
		%Dipendenza generica, Associazione, Aggregazione..
        %Meglio qui o lasciamo sopra?


		\paragraph{Diagrammi di attività}\label{PP:Sviluppo:DiagrammiAttività} %TODO
		Li usiamo per descrivere la logica dell'applicazione, ovvero quali attività si possono presentare e in quali sequenze vengono svolte. Rappresentano quindi la parte dinamica dei casi d'uso.
        Questi diagrammi presentano i seguenti componenti:
        
        

		\subparagraph{Semantica} %TODO
		%Ogni diagramma inizia con uno stato iniziale segnato con un pallino nero, ogni transizione è una freccia....


		\paragraph{Diagrammi di sequenza}\label{PP:Sviluppo:DiagrammiSequenza} %TODO
		%Contenuto

		\subparagraph{Semantica} %TODO
		%Essendo il diagramma di sequenza composto da una serie di scelte già decise è molto utile ai fini di un chiaro utilizzo la decisione di una serie di partecipanti. La lettura del diagramma avviene dall’alto verso il basso....


		\paragraph{Diagrammi dei casi d'uso}\label{PP:Sviluppo:DiagrammiCasiUso}
		Per i diagrammi dei casi d'uso utilizziamo lo strumento \gloss{Draw.io} e il linguaggio \gloss{UML} 2.0. Essi descrivono la visione di un utente
		esterno al sistema e non danno nessun dettaglio implementativo. I \gloss{componenti} contenuti in questo tipo di diagrammi sono:
		\begin{itemize}
			\item \gloss{Attore}
			\item Casi d'uso
			\item Relazioni, che possono essere di:
			\begin{itemize}
				\item \textbf{Associazione}: è sempre presente e rappresenta una comunicazione diretta dell'attore con il caso d'uso.
				\item \textbf{Inclusione}: è una funzionalità comune che coinvolge più casi d'uso, in cui ogni istanza del primo esegue
					necessariamente il secondo. Tutte le inclusioni vengono sempre eseguite dall'utente.
				\item \textbf{Estensione}: aumenta le funzionalità di un caso d'uso coinvolgendone un altro. L'esecuzione di quest'ultimo interrompe il precedente, ma non è necessariamente detto che tutte le estensioni vengano eseguite.
				\item \textbf{Generalizzazione}: avviene tra casi d'uso o tra attori e rappresenta delle modifiche alle caratteristiche di base.
			\end{itemize}
		\end{itemize}
		Per la specifica di un caso d'uso si fa riferimento al paragrafo \S\ref{PP:Sviluppo:AdR:CasiUso}.


		\subsubsection{Qualità della progettazione}\label{PP:Sviluppo:QualitàProgettazione} %TODO
		%Di seguito elenchiamo le linee guida da seguire per garantire una progettazione di qualità.

		\paragraph{Qualità dei diagrammi delle classi} %TODO
		%Evitare le dipendenze circolari....

		\paragraph{Qualità dei diagrammi di attività} %TODO
		%Contenuto

		\paragraph{Qualità dei diagrammi di sequenza} %TODO
		%Contenuto

		\paragraph{Qualità dei diagrammi dei casi d'uso} %TODO: facoltativo..
		%Contenuto

		%manuale utente da presentare in RQ, quindi da fare più avanti
		%\subsubsection{Produzione del manuale utente}


		\subsubsection{Codifica}\label{PP:Sviluppo:Codifica}
		% TODO: scrivere nei prossimi paragrafi tutto quello che potrebbe essere idealmente scritto in un file di checkstyle. Struttura presa come spunto da Breaking Bug RA.

		\paragraph{Scopo}
		La presente sezione ha lo scopo di normare l'attività di codifica che svolgeremo nel corso della realizzazione del progetto \progetto, per
		evitare qualsiasi tipo di inconsistenza e rendere il codice il quanto più omogeneo possibile.

		Il progetto sarà sviluppato perlopiù usando il linguaggio \gloss{Python} (per una parte sarà valutato se utilizzare Ruby).
		Per le norme di stile relative a questo linguaggio, seguiremo il PEP 8\footnote{Riferirsi alla voce ``PEP 8'' in \S\ref{rifnorma}},
		lo standard Python che definisce lo stile da seguire nella codifica e in attività correlate ad essa.

        \paragraph{Intestazione} %TODO
		Ogni sorgente Python conterrà la seguente intestazione:
		\begin{verbatim}
			"""
			File:	<nomefile.estensione>
			Data creazione: <YYYY-MM-DD>

			<descrizione>

			Licenza:	<nome licenza>
			Versione:	<X.Y.Z>
			Creatore:	<nome cognome: email>
			Autori:
				<nome cognome: email>
				<nome cognome: email>
				....
			"""
		\end{verbatim}

		\paragraph{Formattazione}
		Viene utilizzato uno spazio per separare simboli e identificatori.
		\lstinputlisting{py/format.py}


		\paragraph{Convenzioni di nominazione}
		\begin{itemize}
			\item Per i nomi delle classi, viene usato \texttt{PascalCase}\footnote{Riferirsi alla voce ``Naming convention'' in \S\ref{rifinfo}}
			\item Per le costanti, viene usato \texttt{MACRO\_CASE}
			\item Per denominare tutto il resto, ad esempio variabili e metodi, si usa \texttt{snake\_case}
		\end{itemize}

		Inoltre, tutti gli identificativi devono avere dei nomi significativi, relativi al contesto e alla loro utilità.
\begin{lstlisting}[language=Python]
uscita = True		# Si
a = True			# No

count_match = 0		# Si
b = 0				# No

def somma(x, y):	# Si, x e y sono concessi per il chiaro contesto matematico
	return x + y
def foo(a, b):		# No
	return a + b
\end{lstlisting}

        % \paragraph{Funzioni anonime} %TODO Solo in caso di necessità
        %Contenuto

        \paragraph{Indentazione}
		Per l'indentazione, come da PEP 8, si usano 4 spazi. L'IDE utilizzato dovrà essere configurato in modo che, premendo il
		tasto TAB, verranno generati 4 spazi.

		\paragraph{Stringhe}
		Preferire l'uso del carattere di apice singolo (') per circondare le stringhe. Usare il doppio apice (") solo per aumentare la
		leggibilità in caso sia presente nella stringa un apice singolo, o per le stringhe di documentazione (circondate da tripli apici doppi).\par
		Per ottenere stringhe formattabili con parametri, usare le f-stringhe introdotte con Python 3.6, o, in caso di migliore leggibilità, usare la funzione \texttt{format()}.

\begin{lstlisting}[language=Python]
stringa = 'una stringa'
def foo(x):
	"""Stringa di documentazione"""
	pass
f_stringa = f'{stringa} parametrizzata!'
\end{lstlisting}

        \paragraph{Lunghezza massima delle righe}
        %Contenuto
		Le righe di codice devono avere una lunghezza massima di 79 caratteri. Le righe di documentazione relative ad esempio a un metodo,
		invece, non devono contenere più di 72 caratteri.
		A tal fine, vengono divisi in più righe le istruzioni che superano il limite massimo di caratteri, per migliorare la leggibilità.

		\begin{lstlisting}[language=Python]
with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
	file_2.write(file_1.read())
		\end{lstlisting}


		\paragraph{Lunghezza massima di metodi e funzioni}
		Il numero massimo di righe per ogni metodo o funzione viene fissato a 50 linee di codice, numero necessario ad occupare un'intera
		schermata su un comune IDE. Funzioni più lunghe di 50 righe sono quasi sicuramente sintomo di una funzione che svolge troppi compiti,
		che sarebbe spacchettabile in più funzioni.

		\paragraph{Parametri delle funzioni}
		Per i parametri delle funzioni, usare dei nomi esplicativi se il numero dei parametri non supera i 6. Altrimenti, preferire l'uso di liste
		arbitrarie di parametri e l'uso di coppie chiavi-valori. Documentare, di conseguenza,
		i nomi dei parametri che l'operatore ** (per le coppie chiave-valore) si aspetta, e sollevare una eccezione appropriata in caso si ottenga una chiave
		inaspettata.
\begin{lstlisting}[language=Python]
def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments:
        print(arg)
    print("-" * 40)
    for kw in keywords:
        print(kw, ":", keywords[kw])
\end{lstlisting}

        \paragraph{Complessità ciclomatica}
		Va evitato il più possibile l'annidamento di più strutture di controllo. Per questo, stare sotto i tre livelli di annidamento è una buona
		prassi che semplifica leggibilità e \gloss{debugging} e va rispettata il più possibile.


		\paragraph{Ereditarietà}
		Evitare l'ereditarietà tra classi che hanno stato. È invece possibile che una classe derivi da un'altra se quest'ultima è a tutti gli
		effetti un'\gloss{interfaccia}, ossia definisce solo comportamenti astratti (i.e. è composta solo da metodi astratti).\par
		Viene adottato, per ovviare alla assente ereditarietà, il principio di ``Composition over inheritance''\footnote{Riferirsi alla voce %
		``Composition over inheritance'' in \S\ref{rifnorma}.}.


        \paragraph{Commenti}
		Il \Progr\ è tenuto ad inserire commenti ove ritiene che questo possa migliorare la leggibilità del codice. Per contro, i commenti vanno
		omessi dove il codice è auto esplicatorio.\par
		Per inserire un commento, far seguire al simbolo di commento (\texttt{\#}) uno spazio, e iniziare con una lettera maiuscola (e.g.
		\texttt{\#\ Cerca il match del parametro x nella lista}). In caso di commento su più righe, solo la prima riga va iniziata con carattere
		maiuscolo.

        % \paragraph{Codetags} % TODO: e mettere parola in gloss
        % Già presente nei processi organizzativi, alla sezione "Gestione dei problemi emersi"

        % TODO: Per altri formalismi da aggiungere, vedere un po' dei punti del link: http://checkstyle.sourceforge.net/checks.html

        \subsubsection{Metriche per la codifica} % TODO: prendere spunto da 3.2.4.2.4 della RA di Breaking Bug
		DA FARE

        \subsubsection{Strumenti di base}\label{PP:Sviluppo:Strumenti}

	    \paragraph{Ambiente di sviluppo}\label{PP:Sviluppo:Strumenti:AmbienteSviluppo}
	    Nei paragrafi successivi vengono riportate le componenti software utilizzate da ogni membro del team per lo sviluppo del progetto.


	    \subparagraph{Sistema operativo}\label{PP:Sviluppo:Strumenti:AmbienteSviluppo:SistemaOperativo}
	    Abbiamo deciso di usare, come sistema operativo, GNU/Linux, in particolare una qualsiasi distribuzione basata su Ubuntu 18.04.

	    \subparagraph{IDE}\label{PP:Sviluppo:Strumenti:AmbienteSviluppo:IDE} % NOTE: controllare la sezione relativa a VSC sui processi di supporto
		Gli IDE principali scelti per lo sviluppo di codice Python sono
		{PyCharm}\footnote{Riferirsi alla voce ``Pycharm'' in \S\ref{rifinfo}} e
		{Visual Studio Code}\footnote{Riferirsi alla voce ``Visual Studio Code'' in \S\ref{rifinfo}}.
		Il primo è proprietario e supportato dal team di IntelliJ, il secondo è un progetto \gloss{open source} di Microsoft, che ha
		per questo il supporto della comunità open source.\par
		Entrambi offrono la maggior parte dei vantaggi utili al processo di sviluppo di \progetto, tra cui:
		\begin{itemize}
			\item Highlighting del codice per una lettura agevole
			\item Pylint, un \gloss{linter} per Python per l'analisi in tempo reale della qualità del codice
			\item Debugging
			\item Supporto a una miriade di plugin esterni
		\end{itemize}

		\begin{figure}[H]
			\includegraphics[width=\textwidth]{img/pycharm.png}
			\caption{Interfaccia grafica di PyCharm}
		\end{figure}
